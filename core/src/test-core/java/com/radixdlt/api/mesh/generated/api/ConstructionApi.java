/*
 * Rosetta
 * Build Once. Integrate Your Blockchain Everywhere. 
 *
 * The version of the OpenAPI document: 1.4.13
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.radixdlt.api.mesh.generated.api;

import com.radixdlt.api.mesh.generated.client.ApiClient;
import com.radixdlt.api.mesh.generated.client.ApiException;
import com.radixdlt.api.mesh.generated.client.ApiResponse;
import com.radixdlt.api.mesh.generated.client.Pair;

import com.radixdlt.api.mesh.generated.models.ConstructionCombineRequest;
import com.radixdlt.api.mesh.generated.models.ConstructionCombineResponse;
import com.radixdlt.api.mesh.generated.models.ConstructionDeriveRequest;
import com.radixdlt.api.mesh.generated.models.ConstructionDeriveResponse;
import com.radixdlt.api.mesh.generated.models.ConstructionHashRequest;
import com.radixdlt.api.mesh.generated.models.ConstructionMetadataRequest;
import com.radixdlt.api.mesh.generated.models.ConstructionMetadataResponse;
import com.radixdlt.api.mesh.generated.models.ConstructionParseRequest;
import com.radixdlt.api.mesh.generated.models.ConstructionParseResponse;
import com.radixdlt.api.mesh.generated.models.ConstructionPayloadsRequest;
import com.radixdlt.api.mesh.generated.models.ConstructionPayloadsResponse;
import com.radixdlt.api.mesh.generated.models.ConstructionPreprocessRequest;
import com.radixdlt.api.mesh.generated.models.ConstructionPreprocessResponse;
import com.radixdlt.api.mesh.generated.models.ConstructionSubmitRequest;
import com.radixdlt.api.mesh.generated.models.Error;
import com.radixdlt.api.mesh.generated.models.TransactionIdentifierResponse;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;

import java.util.ArrayList;
import java.util.StringJoiner;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;

@javax.annotation.processing.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class ConstructionApi {
  private final HttpClient memberVarHttpClient;
  private final ObjectMapper memberVarObjectMapper;
  private final String memberVarBaseUri;
  private final Consumer<HttpRequest.Builder> memberVarInterceptor;
  private final Duration memberVarReadTimeout;
  private final Consumer<HttpResponse<InputStream>> memberVarResponseInterceptor;
  private final Consumer<HttpResponse<String>> memberVarAsyncResponseInterceptor;

  public ConstructionApi() {
    this(new ApiClient());
  }

  public ConstructionApi(ApiClient apiClient) {
    memberVarHttpClient = apiClient.getHttpClient();
    memberVarObjectMapper = apiClient.getObjectMapper();
    memberVarBaseUri = apiClient.getBaseUri();
    memberVarInterceptor = apiClient.getRequestInterceptor();
    memberVarReadTimeout = apiClient.getReadTimeout();
    memberVarResponseInterceptor = apiClient.getResponseInterceptor();
    memberVarAsyncResponseInterceptor = apiClient.getAsyncResponseInterceptor();
  }

  protected ApiException getApiException(String operationId, HttpResponse<InputStream> response) throws IOException {
    String body = response.body() == null ? null : new String(response.body().readAllBytes());
    String message = formatExceptionMessage(operationId, response.statusCode(), body);
    return new ApiException(response.statusCode(), message, response.headers(), body);
  }

  private String formatExceptionMessage(String operationId, int statusCode, String body) {
    if (body == null || body.isEmpty()) {
      body = "[no body]";
    }
    return operationId + " call failed with: " + statusCode + " - " + body;
  }

  /**
   * Create Network Transaction from Signatures
   * Combine creates a network-specific transaction from an unsigned transaction and an array of provided signatures.  The signed transaction returned from this method will be sent to the &#x60;/construction/submit&#x60; endpoint by the caller. 
   * @param constructionCombineRequest  (required)
   * @return ConstructionCombineResponse
   * @throws ApiException if fails to make API call
   */
  public ConstructionCombineResponse constructionCombine(ConstructionCombineRequest constructionCombineRequest) throws ApiException {
    ApiResponse<ConstructionCombineResponse> localVarResponse = constructionCombineWithHttpInfo(constructionCombineRequest);
    return localVarResponse.getData();
  }

  /**
   * Create Network Transaction from Signatures
   * Combine creates a network-specific transaction from an unsigned transaction and an array of provided signatures.  The signed transaction returned from this method will be sent to the &#x60;/construction/submit&#x60; endpoint by the caller. 
   * @param constructionCombineRequest  (required)
   * @return ApiResponse&lt;ConstructionCombineResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<ConstructionCombineResponse> constructionCombineWithHttpInfo(ConstructionCombineRequest constructionCombineRequest) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = constructionCombineRequestBuilder(constructionCombineRequest);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("constructionCombine", localVarResponse);
        }
        return new ApiResponse<ConstructionCombineResponse>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<ConstructionCombineResponse>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder constructionCombineRequestBuilder(ConstructionCombineRequest constructionCombineRequest) throws ApiException {
    // verify the required parameter 'constructionCombineRequest' is set
    if (constructionCombineRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'constructionCombineRequest' when calling constructionCombine");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/construction/combine";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(constructionCombineRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Derive an AccountIdentifier from a PublicKey
   * Derive returns the AccountIdentifier associated with a public key.  Blockchains that require an on-chain action to create an account should not implement this method. 
   * @param constructionDeriveRequest  (required)
   * @return ConstructionDeriveResponse
   * @throws ApiException if fails to make API call
   */
  public ConstructionDeriveResponse constructionDerive(ConstructionDeriveRequest constructionDeriveRequest) throws ApiException {
    ApiResponse<ConstructionDeriveResponse> localVarResponse = constructionDeriveWithHttpInfo(constructionDeriveRequest);
    return localVarResponse.getData();
  }

  /**
   * Derive an AccountIdentifier from a PublicKey
   * Derive returns the AccountIdentifier associated with a public key.  Blockchains that require an on-chain action to create an account should not implement this method. 
   * @param constructionDeriveRequest  (required)
   * @return ApiResponse&lt;ConstructionDeriveResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<ConstructionDeriveResponse> constructionDeriveWithHttpInfo(ConstructionDeriveRequest constructionDeriveRequest) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = constructionDeriveRequestBuilder(constructionDeriveRequest);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("constructionDerive", localVarResponse);
        }
        return new ApiResponse<ConstructionDeriveResponse>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<ConstructionDeriveResponse>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder constructionDeriveRequestBuilder(ConstructionDeriveRequest constructionDeriveRequest) throws ApiException {
    // verify the required parameter 'constructionDeriveRequest' is set
    if (constructionDeriveRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'constructionDeriveRequest' when calling constructionDerive");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/construction/derive";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(constructionDeriveRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Get the Hash of a Signed Transaction
   * TransactionHash returns the network-specific transaction hash for a signed transaction. 
   * @param constructionHashRequest  (required)
   * @return TransactionIdentifierResponse
   * @throws ApiException if fails to make API call
   */
  public TransactionIdentifierResponse constructionHash(ConstructionHashRequest constructionHashRequest) throws ApiException {
    ApiResponse<TransactionIdentifierResponse> localVarResponse = constructionHashWithHttpInfo(constructionHashRequest);
    return localVarResponse.getData();
  }

  /**
   * Get the Hash of a Signed Transaction
   * TransactionHash returns the network-specific transaction hash for a signed transaction. 
   * @param constructionHashRequest  (required)
   * @return ApiResponse&lt;TransactionIdentifierResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<TransactionIdentifierResponse> constructionHashWithHttpInfo(ConstructionHashRequest constructionHashRequest) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = constructionHashRequestBuilder(constructionHashRequest);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("constructionHash", localVarResponse);
        }
        return new ApiResponse<TransactionIdentifierResponse>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<TransactionIdentifierResponse>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder constructionHashRequestBuilder(ConstructionHashRequest constructionHashRequest) throws ApiException {
    // verify the required parameter 'constructionHashRequest' is set
    if (constructionHashRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'constructionHashRequest' when calling constructionHash");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/construction/hash";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(constructionHashRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Get Metadata for Transaction Construction
   * Get any information required to construct a transaction for a specific network. Metadata returned here could be a recent hash to use, an account sequence number, or even arbitrary chain state. The request used when calling this endpoint is created by calling &#x60;/construction/preprocess&#x60; in an offline environment.  You should NEVER assume that the request sent to this endpoint will be created by the caller or populated with any custom parameters. This must occur in &#x60;/construction/preprocess&#x60;.  It is important to clarify that this endpoint should not pre-construct any transactions for the client (this should happen in &#x60;/construction/payloads&#x60;). This endpoint is left purposely unstructured because of the wide scope of metadata that could be required. 
   * @param constructionMetadataRequest  (required)
   * @return ConstructionMetadataResponse
   * @throws ApiException if fails to make API call
   */
  public ConstructionMetadataResponse constructionMetadata(ConstructionMetadataRequest constructionMetadataRequest) throws ApiException {
    ApiResponse<ConstructionMetadataResponse> localVarResponse = constructionMetadataWithHttpInfo(constructionMetadataRequest);
    return localVarResponse.getData();
  }

  /**
   * Get Metadata for Transaction Construction
   * Get any information required to construct a transaction for a specific network. Metadata returned here could be a recent hash to use, an account sequence number, or even arbitrary chain state. The request used when calling this endpoint is created by calling &#x60;/construction/preprocess&#x60; in an offline environment.  You should NEVER assume that the request sent to this endpoint will be created by the caller or populated with any custom parameters. This must occur in &#x60;/construction/preprocess&#x60;.  It is important to clarify that this endpoint should not pre-construct any transactions for the client (this should happen in &#x60;/construction/payloads&#x60;). This endpoint is left purposely unstructured because of the wide scope of metadata that could be required. 
   * @param constructionMetadataRequest  (required)
   * @return ApiResponse&lt;ConstructionMetadataResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<ConstructionMetadataResponse> constructionMetadataWithHttpInfo(ConstructionMetadataRequest constructionMetadataRequest) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = constructionMetadataRequestBuilder(constructionMetadataRequest);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("constructionMetadata", localVarResponse);
        }
        return new ApiResponse<ConstructionMetadataResponse>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<ConstructionMetadataResponse>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder constructionMetadataRequestBuilder(ConstructionMetadataRequest constructionMetadataRequest) throws ApiException {
    // verify the required parameter 'constructionMetadataRequest' is set
    if (constructionMetadataRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'constructionMetadataRequest' when calling constructionMetadata");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/construction/metadata";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(constructionMetadataRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Parse a Transaction
   * Parse is called on both unsigned and signed transactions to understand the intent of the formulated transaction.  This is run as a sanity check before signing (after &#x60;/construction/payloads&#x60;) and before broadcast (after &#x60;/construction/combine&#x60;).  
   * @param constructionParseRequest  (required)
   * @return ConstructionParseResponse
   * @throws ApiException if fails to make API call
   */
  public ConstructionParseResponse constructionParse(ConstructionParseRequest constructionParseRequest) throws ApiException {
    ApiResponse<ConstructionParseResponse> localVarResponse = constructionParseWithHttpInfo(constructionParseRequest);
    return localVarResponse.getData();
  }

  /**
   * Parse a Transaction
   * Parse is called on both unsigned and signed transactions to understand the intent of the formulated transaction.  This is run as a sanity check before signing (after &#x60;/construction/payloads&#x60;) and before broadcast (after &#x60;/construction/combine&#x60;).  
   * @param constructionParseRequest  (required)
   * @return ApiResponse&lt;ConstructionParseResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<ConstructionParseResponse> constructionParseWithHttpInfo(ConstructionParseRequest constructionParseRequest) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = constructionParseRequestBuilder(constructionParseRequest);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("constructionParse", localVarResponse);
        }
        return new ApiResponse<ConstructionParseResponse>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<ConstructionParseResponse>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder constructionParseRequestBuilder(ConstructionParseRequest constructionParseRequest) throws ApiException {
    // verify the required parameter 'constructionParseRequest' is set
    if (constructionParseRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'constructionParseRequest' when calling constructionParse");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/construction/parse";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(constructionParseRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Generate an Unsigned Transaction and Signing Payloads
   * Payloads is called with an array of operations and the response from &#x60;/construction/metadata&#x60;. It returns an unsigned transaction blob and a collection of payloads that must be signed by particular AccountIdentifiers using a certain SignatureType.  The array of operations provided in transaction construction often times can not specify all \&quot;effects\&quot; of a transaction (consider invoked transactions in Ethereum). However, they can deterministically specify the \&quot;intent\&quot; of the transaction, which is sufficient for construction. For this reason, parsing the corresponding transaction in the Data API (when it lands on chain) will contain a superset of whatever operations were provided during construction. 
   * @param constructionPayloadsRequest  (required)
   * @return ConstructionPayloadsResponse
   * @throws ApiException if fails to make API call
   */
  public ConstructionPayloadsResponse constructionPayloads(ConstructionPayloadsRequest constructionPayloadsRequest) throws ApiException {
    ApiResponse<ConstructionPayloadsResponse> localVarResponse = constructionPayloadsWithHttpInfo(constructionPayloadsRequest);
    return localVarResponse.getData();
  }

  /**
   * Generate an Unsigned Transaction and Signing Payloads
   * Payloads is called with an array of operations and the response from &#x60;/construction/metadata&#x60;. It returns an unsigned transaction blob and a collection of payloads that must be signed by particular AccountIdentifiers using a certain SignatureType.  The array of operations provided in transaction construction often times can not specify all \&quot;effects\&quot; of a transaction (consider invoked transactions in Ethereum). However, they can deterministically specify the \&quot;intent\&quot; of the transaction, which is sufficient for construction. For this reason, parsing the corresponding transaction in the Data API (when it lands on chain) will contain a superset of whatever operations were provided during construction. 
   * @param constructionPayloadsRequest  (required)
   * @return ApiResponse&lt;ConstructionPayloadsResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<ConstructionPayloadsResponse> constructionPayloadsWithHttpInfo(ConstructionPayloadsRequest constructionPayloadsRequest) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = constructionPayloadsRequestBuilder(constructionPayloadsRequest);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("constructionPayloads", localVarResponse);
        }
        return new ApiResponse<ConstructionPayloadsResponse>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<ConstructionPayloadsResponse>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder constructionPayloadsRequestBuilder(ConstructionPayloadsRequest constructionPayloadsRequest) throws ApiException {
    // verify the required parameter 'constructionPayloadsRequest' is set
    if (constructionPayloadsRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'constructionPayloadsRequest' when calling constructionPayloads");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/construction/payloads";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(constructionPayloadsRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Create a Request to Fetch Metadata
   * Preprocess is called prior to &#x60;/construction/payloads&#x60; to construct a request for any metadata that is needed for transaction construction given (i.e. account nonce).  The &#x60;options&#x60; object returned from this endpoint will be sent to the &#x60;/construction/metadata&#x60; endpoint UNMODIFIED by the caller (in an offline execution environment). If your Construction API implementation has configuration options, they MUST be specified in the &#x60;/construction/preprocess&#x60; request (in the &#x60;metadata&#x60; field). 
   * @param constructionPreprocessRequest  (required)
   * @return ConstructionPreprocessResponse
   * @throws ApiException if fails to make API call
   */
  public ConstructionPreprocessResponse constructionPreprocess(ConstructionPreprocessRequest constructionPreprocessRequest) throws ApiException {
    ApiResponse<ConstructionPreprocessResponse> localVarResponse = constructionPreprocessWithHttpInfo(constructionPreprocessRequest);
    return localVarResponse.getData();
  }

  /**
   * Create a Request to Fetch Metadata
   * Preprocess is called prior to &#x60;/construction/payloads&#x60; to construct a request for any metadata that is needed for transaction construction given (i.e. account nonce).  The &#x60;options&#x60; object returned from this endpoint will be sent to the &#x60;/construction/metadata&#x60; endpoint UNMODIFIED by the caller (in an offline execution environment). If your Construction API implementation has configuration options, they MUST be specified in the &#x60;/construction/preprocess&#x60; request (in the &#x60;metadata&#x60; field). 
   * @param constructionPreprocessRequest  (required)
   * @return ApiResponse&lt;ConstructionPreprocessResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<ConstructionPreprocessResponse> constructionPreprocessWithHttpInfo(ConstructionPreprocessRequest constructionPreprocessRequest) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = constructionPreprocessRequestBuilder(constructionPreprocessRequest);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("constructionPreprocess", localVarResponse);
        }
        return new ApiResponse<ConstructionPreprocessResponse>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<ConstructionPreprocessResponse>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder constructionPreprocessRequestBuilder(ConstructionPreprocessRequest constructionPreprocessRequest) throws ApiException {
    // verify the required parameter 'constructionPreprocessRequest' is set
    if (constructionPreprocessRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'constructionPreprocessRequest' when calling constructionPreprocess");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/construction/preprocess";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(constructionPreprocessRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Submit a Signed Transaction
   * Submit a pre-signed transaction to the node. This call should not block on the transaction being included in a block. Rather, it should return immediately with an indication of whether or not the transaction was included in the mempool.  The transaction submission response should only return a 200 status if the submitted transaction could be included in the mempool. Otherwise, it should return an error. 
   * @param constructionSubmitRequest  (required)
   * @return TransactionIdentifierResponse
   * @throws ApiException if fails to make API call
   */
  public TransactionIdentifierResponse constructionSubmit(ConstructionSubmitRequest constructionSubmitRequest) throws ApiException {
    ApiResponse<TransactionIdentifierResponse> localVarResponse = constructionSubmitWithHttpInfo(constructionSubmitRequest);
    return localVarResponse.getData();
  }

  /**
   * Submit a Signed Transaction
   * Submit a pre-signed transaction to the node. This call should not block on the transaction being included in a block. Rather, it should return immediately with an indication of whether or not the transaction was included in the mempool.  The transaction submission response should only return a 200 status if the submitted transaction could be included in the mempool. Otherwise, it should return an error. 
   * @param constructionSubmitRequest  (required)
   * @return ApiResponse&lt;TransactionIdentifierResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<TransactionIdentifierResponse> constructionSubmitWithHttpInfo(ConstructionSubmitRequest constructionSubmitRequest) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = constructionSubmitRequestBuilder(constructionSubmitRequest);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("constructionSubmit", localVarResponse);
        }
        return new ApiResponse<TransactionIdentifierResponse>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<TransactionIdentifierResponse>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder constructionSubmitRequestBuilder(ConstructionSubmitRequest constructionSubmitRequest) throws ApiException {
    // verify the required parameter 'constructionSubmitRequest' is set
    if (constructionSubmitRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'constructionSubmitRequest' when calling constructionSubmit");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/construction/submit";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(constructionSubmitRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
}
