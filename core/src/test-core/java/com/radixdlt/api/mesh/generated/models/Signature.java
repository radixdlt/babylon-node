/*
 * Rosetta
 * Build Once. Integrate Your Blockchain Everywhere. 
 *
 * The version of the OpenAPI document: 1.4.13
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.radixdlt.api.mesh.generated.models;

import java.util.Objects;
import java.util.Arrays;
import java.util.Map;
import java.util.HashMap;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import com.radixdlt.api.mesh.generated.models.PublicKey;
import com.radixdlt.api.mesh.generated.models.SignatureType;
import com.radixdlt.api.mesh.generated.models.SigningPayload;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;


/**
 * Signature contains the payload that was signed, the public keys of the keypairs used to produce the signature, the signature (encoded in hex), and the SignatureType.  PublicKey is often times not known during construction of the signing payloads but may be needed to combine signatures properly. 
 */
@ApiModel(description = "Signature contains the payload that was signed, the public keys of the keypairs used to produce the signature, the signature (encoded in hex), and the SignatureType.  PublicKey is often times not known during construction of the signing payloads but may be needed to combine signatures properly. ")
@JsonPropertyOrder({
  Signature.JSON_PROPERTY_SIGNING_PAYLOAD,
  Signature.JSON_PROPERTY_PUBLIC_KEY,
  Signature.JSON_PROPERTY_SIGNATURE_TYPE,
  Signature.JSON_PROPERTY_HEX_BYTES
})
@javax.annotation.processing.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class Signature {
  public static final String JSON_PROPERTY_SIGNING_PAYLOAD = "signing_payload";
  private SigningPayload signingPayload;

  public static final String JSON_PROPERTY_PUBLIC_KEY = "public_key";
  private PublicKey publicKey;

  public static final String JSON_PROPERTY_SIGNATURE_TYPE = "signature_type";
  private SignatureType signatureType;

  public static final String JSON_PROPERTY_HEX_BYTES = "hex_bytes";
  private String hexBytes;

  public Signature() { 
  }

  public Signature signingPayload(SigningPayload signingPayload) {
    this.signingPayload = signingPayload;
    return this;
  }

   /**
   * Get signingPayload
   * @return signingPayload
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "")
  @JsonProperty(JSON_PROPERTY_SIGNING_PAYLOAD)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public SigningPayload getSigningPayload() {
    return signingPayload;
  }


  @JsonProperty(JSON_PROPERTY_SIGNING_PAYLOAD)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setSigningPayload(SigningPayload signingPayload) {
    this.signingPayload = signingPayload;
  }


  public Signature publicKey(PublicKey publicKey) {
    this.publicKey = publicKey;
    return this;
  }

   /**
   * Get publicKey
   * @return publicKey
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "")
  @JsonProperty(JSON_PROPERTY_PUBLIC_KEY)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public PublicKey getPublicKey() {
    return publicKey;
  }


  @JsonProperty(JSON_PROPERTY_PUBLIC_KEY)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setPublicKey(PublicKey publicKey) {
    this.publicKey = publicKey;
  }


  public Signature signatureType(SignatureType signatureType) {
    this.signatureType = signatureType;
    return this;
  }

   /**
   * Get signatureType
   * @return signatureType
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "")
  @JsonProperty(JSON_PROPERTY_SIGNATURE_TYPE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public SignatureType getSignatureType() {
    return signatureType;
  }


  @JsonProperty(JSON_PROPERTY_SIGNATURE_TYPE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setSignatureType(SignatureType signatureType) {
    this.signatureType = signatureType;
  }


  public Signature hexBytes(String hexBytes) {
    this.hexBytes = hexBytes;
    return this;
  }

   /**
   * Get hexBytes
   * @return hexBytes
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "")
  @JsonProperty(JSON_PROPERTY_HEX_BYTES)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getHexBytes() {
    return hexBytes;
  }


  @JsonProperty(JSON_PROPERTY_HEX_BYTES)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setHexBytes(String hexBytes) {
    this.hexBytes = hexBytes;
  }


  /**
   * Return true if this Signature object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Signature signature = (Signature) o;
    return Objects.equals(this.signingPayload, signature.signingPayload) &&
        Objects.equals(this.publicKey, signature.publicKey) &&
        Objects.equals(this.signatureType, signature.signatureType) &&
        Objects.equals(this.hexBytes, signature.hexBytes);
  }

  @Override
  public int hashCode() {
    return Objects.hash(signingPayload, publicKey, signatureType, hexBytes);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Signature {\n");
    sb.append("    signingPayload: ").append(toIndentedString(signingPayload)).append("\n");
    sb.append("    publicKey: ").append(toIndentedString(publicKey)).append("\n");
    sb.append("    signatureType: ").append(toIndentedString(signatureType)).append("\n");
    sb.append("    hexBytes: ").append(toIndentedString(hexBytes)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

