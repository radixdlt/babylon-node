/*
 * Rosetta
 * Build Once. Integrate Your Blockchain Everywhere. 
 *
 * The version of the OpenAPI document: 1.4.13
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.radixdlt.api.mesh.generated.models;

import java.util.Objects;
import java.util.Arrays;
import java.util.Map;
import java.util.HashMap;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import com.radixdlt.api.mesh.generated.models.BlockIdentifier;
import com.radixdlt.api.mesh.generated.models.Coin;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.util.ArrayList;
import java.util.List;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;


/**
 * AccountCoinsResponse is returned on the /account/coins endpoint and includes all unspent Coins owned by an AccountIdentifier. 
 */
@ApiModel(description = "AccountCoinsResponse is returned on the /account/coins endpoint and includes all unspent Coins owned by an AccountIdentifier. ")
@JsonPropertyOrder({
  AccountCoinsResponse.JSON_PROPERTY_BLOCK_IDENTIFIER,
  AccountCoinsResponse.JSON_PROPERTY_COINS,
  AccountCoinsResponse.JSON_PROPERTY_METADATA
})
@javax.annotation.processing.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class AccountCoinsResponse {
  public static final String JSON_PROPERTY_BLOCK_IDENTIFIER = "block_identifier";
  private BlockIdentifier blockIdentifier;

  public static final String JSON_PROPERTY_COINS = "coins";
  private List<Coin> coins = new ArrayList<>();

  public static final String JSON_PROPERTY_METADATA = "metadata";
  private Object metadata;

  public AccountCoinsResponse() { 
  }

  public AccountCoinsResponse blockIdentifier(BlockIdentifier blockIdentifier) {
    this.blockIdentifier = blockIdentifier;
    return this;
  }

   /**
   * Get blockIdentifier
   * @return blockIdentifier
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "")
  @JsonProperty(JSON_PROPERTY_BLOCK_IDENTIFIER)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public BlockIdentifier getBlockIdentifier() {
    return blockIdentifier;
  }


  @JsonProperty(JSON_PROPERTY_BLOCK_IDENTIFIER)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setBlockIdentifier(BlockIdentifier blockIdentifier) {
    this.blockIdentifier = blockIdentifier;
  }


  public AccountCoinsResponse coins(List<Coin> coins) {
    this.coins = coins;
    return this;
  }

  public AccountCoinsResponse addCoinsItem(Coin coinsItem) {
    this.coins.add(coinsItem);
    return this;
  }

   /**
   * If a blockchain is UTXO-based, all unspent Coins owned by an account_identifier should be returned alongside the balance. It is highly recommended to populate this field so that users of the Rosetta API implementation don&#39;t need to maintain their own indexer to track their UTXOs. 
   * @return coins
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "If a blockchain is UTXO-based, all unspent Coins owned by an account_identifier should be returned alongside the balance. It is highly recommended to populate this field so that users of the Rosetta API implementation don't need to maintain their own indexer to track their UTXOs. ")
  @JsonProperty(JSON_PROPERTY_COINS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public List<Coin> getCoins() {
    return coins;
  }


  @JsonProperty(JSON_PROPERTY_COINS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setCoins(List<Coin> coins) {
    this.coins = coins;
  }


  public AccountCoinsResponse metadata(Object metadata) {
    this.metadata = metadata;
    return this;
  }

   /**
   * Account-based blockchains that utilize a nonce or sequence number should include that number in the metadata. This number could be unique to the identifier or global across the account address. 
   * @return metadata
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "{\"sequence_number\":23}", value = "Account-based blockchains that utilize a nonce or sequence number should include that number in the metadata. This number could be unique to the identifier or global across the account address. ")
  @JsonProperty(JSON_PROPERTY_METADATA)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Object getMetadata() {
    return metadata;
  }


  @JsonProperty(JSON_PROPERTY_METADATA)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setMetadata(Object metadata) {
    this.metadata = metadata;
  }


  /**
   * Return true if this AccountCoinsResponse object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    AccountCoinsResponse accountCoinsResponse = (AccountCoinsResponse) o;
    return Objects.equals(this.blockIdentifier, accountCoinsResponse.blockIdentifier) &&
        Objects.equals(this.coins, accountCoinsResponse.coins) &&
        Objects.equals(this.metadata, accountCoinsResponse.metadata);
  }

  @Override
  public int hashCode() {
    return Objects.hash(blockIdentifier, coins, metadata);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class AccountCoinsResponse {\n");
    sb.append("    blockIdentifier: ").append(toIndentedString(blockIdentifier)).append("\n");
    sb.append("    coins: ").append(toIndentedString(coins)).append("\n");
    sb.append("    metadata: ").append(toIndentedString(metadata)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

